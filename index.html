// --- PLAYER DATA ---
        let playerData = [];

        // --- EMPTY PROFILE TEMPLATE ---
        const emptyProfileTemplate = {
            fullName: "",
            shirtNumber: "",
            photoUrl: "https://placehold.co/300x300/cccccc/ffffff?text=Upload",
            data: {
                leadership: { "Influence": 5, "By Example": 5, "Vocal": 5, "Empathy": 5, "Listening": 5, "Expressive": 5, "Positive Energy": 5, "Accountability": 5 },
                personality: { "Energy Style": "Ambivert", "Information Style": "Pragmatist", "Decision Style": "Logical", "Lifestyle": "Planner" },
                communication: { "Clarity": 5, "Receptiveness": 5, "Task Cohesion": "Optimal", "Social Cohesion": "Optimal", "Team Connection": "Optimal", "Spontaneity": "Optimal", "Honest Comms": "Optimal" },
                mentalSkills: { "Resilience": 5, "Mental Energy": 5, "Achievement Drive": 5, "Growth Mindset": 5 },
                copingSkills: { "Problem Solving": 5, "Emotional Regulation": 5, "Self Talk": "Positive" },
                cognitiveProfile: { "Motivation": "Towards Pleasure", "Focus Style": "Solution Focus", "Action Style": "Proactive", "Information Style": "Global", "Reasoning Style": "Optional", "Primary System": "Visual" }
            }
        };

        // --- SECTION DEFINITIONS (GLOBAL) ---
        const sections = {
            leadership: { title: "Leadership Profile", type: 'score' },
            personality: { title: "Personality Profile", type: 'multi', options: { "Energy Style": ["Introvert", "Ambivert", "Extrovert"], "Information Style": ["Pragmatist", "Visionary"], "Decision Style": ["Logical", "Empathetic"], "Lifestyle": ["Planner", "Adapter"] }},
            communication: { title: "Communication & Group Climate", type: 'mixed', score_params: ["Clarity", "Receptiveness"], multi_params: { "Task Cohesion": ["Low", "Optimal", "High"], "Social Cohesion": ["Low", "Optimal", "High"], "Team Connection": ["Low", "Optimal", "High"], "Spontaneity": ["Low", "Optimal", "High"], "Honest Comms": ["Low", "Optimal", "High"] }},
            mentalSkills: { title: "Mental Skills", type: 'score' },
            copingSkills: { title: "Coping Skills", type: 'mixed', score_params: ["Problem Solving", "Emotional Regulation"], multi_params: { "Self Talk": ["Positive", "Negative"] }},
            cognitiveProfile: { title: "Cognitive & Motivational Profile", type: 'multi', options: { "Motivation": ["Towards Pleasure", "Away From Pain"], "Focus Style": ["Solution Focus", "Problem Focus"], "Action Style": ["Proactive", "Reactive"], "Information Style": ["Global", "Specific"], "Reasoning Style": ["Optional", "Procedural"], "Primary System": ["Visual", "Auditory", "Kinesthetic"] }}
        };

        function initializeData() {
            const savedData = localStorage.getItem('kvcWesterloMentalProfiles');
            if (savedData) {
                const loadedProfiles = JSON.parse(savedData);
                
                // Safely merge saved data with the new template
                playerData = loadedProfiles.map(savedProfile => {
                    const newProfile = JSON.parse(JSON.stringify(emptyProfileTemplate));
                    
                    // Merge data section by section to preserve saved values and add new ones
                    for (const sectionKey in newProfile.data) {
                        if (savedProfile.data && savedProfile.data[sectionKey]) {
                            for (const paramKey in newProfile.data[sectionKey]) {
                                if (savedProfile.data[sectionKey][paramKey] !== undefined) {
                                    newProfile.data[sectionKey][paramKey] = savedProfile.data[sectionKey][paramKey];
                                }
                            }
                        }
                    }
                    
                    // Copy top-level info
                    newProfile.fullName = savedProfile.fullName || "";
                    newProfile.shirtNumber = savedProfile.shirtNumber || "";
                    newProfile.photoUrl = savedProfile.photoUrl || emptyProfileTemplate.photoUrl;

                    return newProfile;
                });

                // Ensure there are always at least 35 profiles
                while (playerData.length < 35) {
                    playerData.push(JSON.parse(JSON.stringify(emptyProfileTemplate)));
                }

            } else {
                // Add 35 empty profiles if no saved data
                for (let i = 0; i < 35; i++) {
                    playerData.push(JSON.parse(JSON.stringify(emptyProfileTemplate)));
                }
            }
        }


        function getScoreBackground(value) {
            const red = '#EF233C', orange = '#FFA500', yellow = '#FFFF00', 
                  lightGreen = '#ADFF2F', green = '#7CFC00', fullGreen = '#32CD32', darkGreen = '#228B22';
            if (value <= 4) return `background-color: ${red};`;
            if (value === 5) return `background: linear-gradient(to right, ${orange} 60%, ${yellow} 100%);`;
            if (value === 6) return `background: linear-gradient(to right, ${orange} 25%, ${yellow} 75%);`;
            if (value === 7) return `background: linear-gradient(to right, ${yellow} 50%, ${lightGreen} 100%);`;
            if (value === 8) return `background: linear-gradient(to right, ${lightGreen} 50%, ${green} 100%);`;
            if (value === 9) return `background-color: ${fullGreen};`;
            if (value >= 10) return `background-color: ${darkGreen};`;
            return `background-color: #cccccc;`;
        }
        
        function getAverageScoreBackground(value) {
             const red = '#EF233C', orange = '#FFA500', lightGreen = '#ADFF2F', fullGreen = '#32CD32';
            if (value < 5) return red;
            if (value < 7) return orange;
            if (value < 8) return lightGreen;
            return fullGreen;
        }

        function createParameterHTML(player, playerIndex) {
            const column1Keys = ['leadership', 'personality', 'mentalSkills'];
            const column2Keys = ['communication', 'copingSkills', 'cognitiveProfile'];
            
            let column1HTML = '';
            let column2HTML = '';

            Object.keys(sections).forEach(sectionKey => {
                const section = sections[sectionKey];
                
                let averageScoreHTML = '';
                if (section.type === 'score' || section.type === 'mixed') {
                    const scores = [];
                    const scoreKeys = section.type === 'mixed' ? section.score_params : Object.keys(player.data[sectionKey]);
                    scoreKeys.forEach(key => { if (typeof player.data[sectionKey][key] === 'number') { scores.push(player.data[sectionKey][key]); }});
                    if(scores.length > 0) {
                        const sum = scores.reduce((a, b) => a + b, 0);
                        const avg = (sum / scores.length).toFixed(1);
                        averageScoreHTML = `<div class="average-score-container" data-avg-section="${sectionKey}"><div class="average-score-bullet" style="background-color: ${getAverageScoreBackground(avg)}">${avg}</div><div class="average-score-label">average</div></div>`;
                    }
                }

                let sectionHTML = `<div class="parameter-section"><div class="section-header"><h3>${section.title}</h3>${averageScoreHTML}</div>`;
                
                for (const paramKey in player.data[sectionKey]) {
                    const value = player.data[sectionKey][paramKey];
                    sectionHTML += `<div class="parameter"><div class="parameter-name">${paramKey}</div>`;

                    if (section.type === 'score' || (section.type === 'mixed' && section.score_params.includes(paramKey))) {
                        const textColorClass = (value >= 5 && value <= 7) ? 'dark-text' : '';
                        sectionHTML += `<div class="score-bar-container" data-player-index="${playerIndex}" data-section="${sectionKey}" data-param="${paramKey}"><div class="score-bar" style="width: ${value * 10}%; ${getScoreBackground(value)}"><span class="score-value ${textColorClass}">${value}</span></div></div>`;
                    } else if (section.type === 'multi' || (section.type === 'mixed' && section.multi_params[paramKey])) {
                        const options = section.type === 'multi' ? section.options[paramKey] : section.multi_params[paramKey];
                        sectionHTML += `<div class="multi-option-bar" data-player-index="${playerIndex}" data-section="${sectionKey}" data-param="${paramKey}">`;
                        options.forEach(option => {
                            let isSelectedClass = 'not-selected';
                            if (option === value) {
                                if (sectionKey === 'communication' && (option === 'Low' || option === 'High')) {
                                    isSelectedClass = 'selected-warn';
                                } else {
                                    isSelectedClass = 'selected';
                                }
                            }
                            sectionHTML += `<div class="multi-option ${isSelectedClass}">${option}</div>`;
                        });
                        sectionHTML += `</div>`;
                    }
                    sectionHTML += `</div>`;
                }
                sectionHTML += `</div>`;
                
                if (column1Keys.includes(sectionKey)) { column1HTML += sectionHTML; } else { column2HTML += sectionHTML; }
            });

            return `<div class="content-column">${column1HTML}</div><div class="content-column">${column2HTML}</div>`;
        }

        function generatePlayerCards() {
            const container = document.getElementById('cards-container');
            if (!container) return;

            let allCardsHTML = '';
            playerData.forEach((player, index) => {
                const parametersHTML = createParameterHTML(player, index);
                const cardId = `player-card-${index}`;
                
                allCardsHTML += `
                    <div class="player-card" id="${cardId}" data-player-index="${index}">
                        <div class="card-header">
                             <div class="header-player-info">
                                <img id="photo-${index}" src="${player.photoUrl}" alt="Photo of ${player.fullName}" onclick="triggerPhotoUpload('${index}')" onerror="this.onerror=null;this.src='https://placehold.co/300x300/cccccc/ffffff?text=Photo';">
                                <div class="player-details">
                                    <input type="text" class="player-name-input" value="${player.fullName}" placeholder="Player Name" onchange="updatePlayerData(${index}, 'fullName', this.value)">
                                    <input type="text" class="shirt-number-input" value="${player.shirtNumber ? 'Shirt Nr: ' + player.shirtNumber : ''}" placeholder="Shirt Nr" onchange="updatePlayerData(${index}, 'shirtNumber', this.value.replace('Shirt Nr: ', ''))">
                                </div>
                             </div>
                            <h1>Mental Profile</h1>
                            <div class="header-actions no-print">
                                 <button class="action-button save-button" onclick="saveAllData(this)">Save All</button>
                                 <button class="action-button" onclick="saveCardAsPDF('${cardId}')">Save as PDF</button>
                            </div>
                        </div>
                        <div class="card-content">
                            ${parametersHTML}
                        </div>
                    </div>
                `;
            });
            container.innerHTML = allCardsHTML;
            addDragListeners();
            addMultiOptionListeners();
        }
        
        function updatePlayerData(playerIndex, key, value) {
            playerData[playerIndex][key] = value;
        }

        function triggerPhotoUpload(index) {
            const uploadId = `upload-${index}`;
            if (!document.getElementById(uploadId)) {
                const input = document.createElement('input');
                input.type = 'file';
                input.className = 'no-print';
                input.id = uploadId;
                input.style.display = 'none';
                input.onchange = (event) => handlePhotoUpload(event, index);
                document.body.appendChild(input);
            }
            document.getElementById(uploadId).click();
        }

        function handlePhotoUpload(event, index) {
            const file = event.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    document.getElementById(`photo-${index}`).src = e.target.result;
                    playerData[index].photoUrl = e.target.result;
                }
                reader.readAsDataURL(file);
            }
        }
        
        // --- INTERACTIVE BAR LOGIC ---
        let currentDragElement = null;

        function addDragListeners() {
            const scoreBarContainers = document.querySelectorAll('.score-bar-container');
            scoreBarContainers.forEach(container => {
                container.addEventListener('mousedown', startDrag);
                container.addEventListener('touchstart', startDrag, { passive: false });
            });
        }
        
        function addMultiOptionListeners() {
            const options = document.querySelectorAll('.multi-option');
            options.forEach(option => {
                option.addEventListener('click', selectMultiOption);
            });
        }

        function selectMultiOption(e) {
            const selectedOption = e.currentTarget;
            const parentBar = selectedOption.parentNode;
            const section = parentBar.dataset.section;
            
            parentBar.querySelectorAll('.multi-option').forEach(opt => {
                opt.classList.remove('selected', 'selected-warn');
                opt.classList.add('not-selected');
            });

            if (section === 'communication' && (selectedOption.textContent === 'Low' || selectedOption.textContent === 'High')) {
                selectedOption.classList.add('selected-warn');
            } else {
                selectedOption.classList.add('selected');
            }
            selectedOption.classList.remove('not-selected');

            const playerIndex = parentBar.dataset.playerIndex;
            const param = parentBar.dataset.param;
            playerData[playerIndex].data[section][param] = selectedOption.textContent;
        }

        function startDrag(e) {
            e.preventDefault();
            currentDragElement = e.currentTarget;
            document.addEventListener('mousemove', drag);
            document.addEventListener('touchmove', drag, { passive: false });
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchend', endDrag);
            updateScoreFromEvent(e);
        }

        function drag(e) {
            if (!currentDragElement) return;
            e.preventDefault();
            updateScoreFromEvent(e);
        }
        
        function endDrag() {
            currentDragElement = null;
            document.removeEventListener('mousemove', drag);
            document.removeEventListener('touchmove', drag);
            document.removeEventListener('mouseup', endDrag);
            document.removeEventListener('touchend', endDrag);
        }

        function updateAverageScore(playerIndex, sectionKey) {
            const player = playerData[playerIndex];
            const section = sections[sectionKey];
            if (!player || !section || (section.type !== 'score' && section.type !== 'mixed')) {
                return;
            }

            const scores = [];
            const scoreKeys = section.type === 'mixed' ? section.score_params : Object.keys(player.data[sectionKey]);
            scoreKeys.forEach(key => {
                if (typeof player.data[sectionKey][key] === 'number') {
                    scores.push(player.data[sectionKey][key]);
                }
            });

            if (scores.length > 0) {
                const sum = scores.reduce((a, b) => a + b, 0);
                const avg = (sum / scores.length).toFixed(1);
                
                const cardElement = document.getElementById(`player-card-${playerIndex}`);
                const avgContainer = cardElement.querySelector(`[data-avg-section="${sectionKey}"]`);
                if (avgContainer) {
                    const avgBullet = avgContainer.querySelector('.average-score-bullet');
                    avgBullet.textContent = avg;
                    avgBullet.style.backgroundColor = getAverageScoreBackground(avg);
                }
            }
        }

        function updateScoreFromEvent(e) {
            const rect = currentDragElement.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            let x = clientX - rect.left;
            let percentage = (x / rect.width) * 100;
            
            percentage = Math.max(0, Math.min(100, percentage));
            let score = Math.round(percentage / 10);
            score = Math.max(0, Math.min(10, score)); // Now allows 0

            const scoreBar = currentDragElement.querySelector('.score-bar');
            const scoreValue = currentDragElement.querySelector('.score-value');
            scoreBar.style.width = `${score * 10}%`;
            scoreBar.style.cssText += getScoreBackground(score);
            scoreValue.textContent = score;
            scoreValue.classList.toggle('dark-text', score >= 5 && score <= 7);

            const playerIndex = currentDragElement.dataset.playerIndex;
            const section = currentDragElement.dataset.section;
            const param = currentDragElement.dataset.param;
            playerData[playerIndex].data[section][param] = score;

            updateAverageScore(playerIndex, section);
        }
        
        // --- SAVE & LOAD LOGIC ---
        function saveAllData(button) {
            localStorage.setItem('kvcWesterloMentalProfiles', JSON.stringify(playerData));
            button.textContent = 'Saved!';
            setTimeout(() => { button.textContent = 'Save All'; }, 2000);
        }

        // --- PDF GENERATION LOGIC ---
        function saveCardAsPDF(cardId) {
            const element = document.getElementById(cardId);
            const playerIndex = element.dataset.playerIndex;
            const playerName = playerData[playerIndex].fullName || "Unnamed_Player";
            const filename = `${playerName}_MP.pdf`;
            
            // Create a clone of the element to modify for printing
            const elementToPrint = element.cloneNode(true);
            
            // On the clone, replace inputs with static text for printing
            const inputs = elementToPrint.querySelectorAll('.player-details input');
            inputs.forEach(input => {
                 const printableText = document.createElement('div');
                 // Copy relevant styles from the input's class
                 if (input.classList.contains('player-name-input')) {
                     printableText.style.fontSize = '1.6em';
                     printableText.style.fontWeight = 'bold';
                     printableText.style.color = '#1a2a4c';
                 } else {
                     printableText.style.fontSize = '1.3em';
                     printableText.style.color = '#555';
                 }
                 printableText.textContent = input.value;
                 input.parentNode.replaceChild(printableText, input);
            });


            const opt = {
                margin:       [5, 5, 5, 5],
                filename:     filename,
                image:        { type: 'jpeg', quality: 0.98 },
                html2canvas:  { scale: 2, useCORS: true },
                jsPDF:        { unit: 'mm', format: 'a4', orientation: 'landscape' }
            };

            const actions = elementToPrint.querySelector('.header-actions');
            if (actions) actions.style.display = 'none';

            html2pdf().set(opt).from(elementToPrint).save();
        }

        window.onload = () => {
            initializeData();
            generatePlayerCards();
        };
